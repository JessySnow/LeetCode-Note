# LeetCode105:从前、中序的遍历结果中构造二叉树

**思路**: 构造的思路和 LeetCode106 类似，也是通过后序遍历的序列找根节点，再根据这个根节点来划分遍历序列的左右子树范围

**递归实现**:

TODO 修复BUG

```java
class Solution {
    HashMap<Integer, Integer> map = new HashMap<>();
    int[] pre;
    
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.pre = preorder;
        for(int i = 0; i < inorder.length; ++ i)
            map.put(inorder[i], i);
        
        TreeNode root = buildTree(0, preorder.length - 1, 0, inorder.length - 1);
        return root;
    }
    
    public TreeNode buildTree(int preStart, int preEnd, int inStart, int inEnd){
        if(preStart > preEnd || inStart > inEnd) return null;
        
        int root = pre[preStart];
        int inRoot = map.get(root);
        TreeNode node = new TreeNode(root);
        
        node.left = buildTree(preStart + 1, preStart + inRoot - inStart - 1, inStart, inRoot - 1);
        node.right = buildTree(preStart + inRoot - inStart, preEnd, inRoot + 1, inEnd);
        
        return node;
    }
}
```
