# 链表总结

## 链表的操作无非增删改查，但是在代码实现上会有很多的坑，比如对于头部节点的特殊处理、链表尾部空指针的处理等

### 为了避免对链表的头部和尾部进行特殊的处理，在做链表的题目时，时常会使用头部哨兵或者尾部哨兵(也叫虚节点)来处理这些特殊情况，我们可以使用哨兵节点指向链表的头部或者尾部(双向链表)，这样链表的头节点相对于哨兵来说就是一个普通的节点，我们不需要对它进行特殊处理，在编写具体的代码时可以带来极大的方便

---

[LeetCode203:移除节点](https://leetcode.com/problems/remove-linked-list-elements/)

#### 移除节点就是哨兵节点的一个很好的应用，假如我们没有设置哨兵节点，我们在进行遍历之前必须保证当前链表的头节点不是需要删除的节点，否则删除了头节点就不能获取链表头的引用了

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        while(head != null && head.val == val)
            head = head.next;
        if(head == null) return head;
        
        
        ListNode index = head;
        while(index != null && index.next != null){
            if(index.next.val == val)
                index.next = index.next.next;
            else index = index.next;
        }
        
        return head;
    }
}
```

#### 在没有哨兵的写法中，在进行链表遍历之前，我们首先对头节点进行了一顿特判，直到头节点的值不为 val，或者头节点为 null，下面看看使用了哨兵节点后的写法，代码的逻辑就简单许多了，因为这时候链表头和其他节点的地位是相同的

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode pre = new ListNode(-1, head);
        ListNode index = pre;
        
        while(index != null && index.next != null){
            if(index.next.val == val)
                index.next = index.next.next;
            else index = index.next;
        }
        
        return pre.next;
    }
}
```

---

[LeetCode707:设计链表](https://leetcode.com/problems/design-linked-list/)

#### 设计链表这道题目考察了对于链表的增、删、查操作，按照链表的链接的方向可以分为单向链表、双向链表，按照是否设置哨兵也有不同的写法，这里采用 JDK8 中链表的实现方式构造一个简单的链表

***PS: JDK8 中的链表采用了双向链表和不设置头节点的写法，可能是为了在数据域比较大的情况下，节省空间吧***

TODO