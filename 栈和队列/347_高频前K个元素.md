# LeetCode347:前 K 个高频元素

**思路一**: 既然要求的是前 K 个高频元素，同时题目说明了返回的元素可以是任意的顺序，那么可以先对数组进行排序，将所有的相同元素放在一起，统计每一个元素出现的次数，并放到一个对象中(对象包含了数字出现次数和该数字的映射关系)，然后将这个对象放到一个大顶堆种。当所有的元素都已经遍历完后，从大顶堆中删除 k 个元素，这 k 个元素就是出现次数最多的元素，如下为大顶堆的定义
```java
// 大顶堆
class maxHeap(){
    // 使用数组作为内部的数据结构
    private Pair[] container;
    private int size;
    private int index;

    public maxHeap(int size){
        this.size = size;
        this.index = 0;
        this.container = new int[size];
    }

    // 向堆中添加新元素，插入到 container 的末尾，并进行上浮操作
    public void add(Pair pair){
        container[++ index] = pair;
        swim(index);
    }

    // 从堆中删除一个元素，将最大的元素删除，并将 container 末尾的元素放到顶端，
    // 同时减少 container 的大小，之后进行 下沉 操作
    public Pair delete(){
        Pair max = container[1];
        swap(1, index --);
        container[index + 1] = null;
        sink(1);
        return max;
    }

    
    /************************* 辅助函数 ***************************/

    // 上浮 -> 元素(k)大于其父节点(k/2)
    private void swim(int k){
        while(k > 1 && less(k / 2, k)){
            swap(k, k / 2);
            k /= 2;
        }
    }

    // 下沉 -> 元素(k)小于其子元素(k * 2 / k * 2 + 1)
    private void sink(int k){
        while(2 * k <= inedx){
            int j = 2 * k;
            if(j < N && less(j, j + 1)) j ++;
            if(!less(k, j)) break;
            swap(k, j);
            k = j;
        }
    }

    private void swap(int i, int j){
        Pair temp = container[i];
        container[i] = container[j];
        container[j] = temp;
    }

    private boolean less(int i, int j){
        return container[i].count < container[j].count;
    }
}

// Pair 对象，映射出现次数和元素的值
class Pair{
    public int count;
    public int val;
    public Pair(int val, int count){
        this.count = count;
        this.val = val;
    }
}
```
***完整代码***
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // 对原始的数组进行排序
        Arrays.sort(nums);
        
        // 构造一个堆
        maxHeap heap = new maxHeap(100000);
        for(int i = 0; i < nums.length;){
            int base = nums[i];
            int j = i;
            while(j < nums.length && nums[j] == nums[i]) ++ j;
            Pair p = new Pair(nums[i], j - i);
            heap.add(p);
            i = j;
        }
        
        // 从堆中删除元素，按照出现次数降序取出出现次数最多的元素
        int[] res = new int[k];
        for(int i = 0; i < k; ++ i){
            res[i] = heap.delete().val;
        }
        return res;
    }
}

class maxHeap{
    // 使用数组作为内部的数据结构
    private Pair[] container;
    private int size;
    private int index;

    public maxHeap(int size){
        this.size = size;
        this.index = 0;
        this.container = new Pair[size];
    }

    // 向堆中添加新元素，插入到 container 的末尾，并进行上浮操作
    public void add(Pair pair){
        container[++ index] = pair;
        swim(index);
    }

    // 从堆中删除一个元素，将最大的元素删除，并将 container 末尾的元素放到顶端，
    // 同时减少 container 的大小，之后进行 下沉 操作
    public Pair delete(){
        Pair max = container[1];
        swap(1, index --);
        container[index + 1] = null;
        sink(1);
        return max;
    }

    
    /************************* 辅助函数 ***************************/

    // 上浮 -> 元素(k)大于其父节点(k/2)
    private void swim(int k){
        while(k > 1 && less(k / 2, k)){
            swap(k, k / 2);
            k /= 2;
        }
    }

    // 下沉 -> 元素(k)小于其子元素(k * 2 / k * 2 + 1)
    private void sink(int k){
        while(2 * k <= index){
            int j = 2 * k;
            if(j < index && less(j, j + 1)) j ++;
            if(!less(k, j)) break;
            swap(k, j);
            k = j;
        }
    }

    private void swap(int i, int j){
        Pair temp = container[i];
        container[i] = container[j];
        container[j] = temp;
    }

    private boolean less(int i, int j){
        return container[i].count < container[j].count;
    }
}

// Pair 对象，映射出现次数和元素的值
class Pair{
    public int count;
    public int val;
    public Pair(int val, int count){
        this.count = count;
        this.val = val;
    }
}
```

---

**思路一(API)**: 使用 Java 提供的优先级队列实现大顶堆
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Arrays.sort(nums);
        PriorityQueue<Pair> pq = new PriorityQueue<>();
        for(int i = 0; i < nums.length;){
            int base = nums[i];
            int j = i;
            while(j < nums.length && nums[i] == nums[j])
                ++ j;
            Pair p = new Pair(base, j - i);
            pq.add(p);
            i = j;
        }
        
        int[] res = new int[k];
        for(int i = 0; i < k; ++ i){
            res[i] = pq.remove().val;
        }
        
        return res;
    }
}

class Pair implements Comparable{
    public int count;
    public int val;
    public Pair(int val, int count){
        this.count = count;
        this.val = val;
    }
    
    @Override
    public int compareTo(Object o){
        Pair otherP = (Pair)o;
        return otherP.count - this.count;
    }
}
```

---

TODO
**思路二**: 上面的思路都是使用大顶堆，堆中存放的元素是按照从大到小的顺序进行排列的所有，需要将数组中的所有元素都存储下来，空间复杂度就非常高，但是我们需要的只有出现次数最多的 k 个元素，这样就造成了大量的空间被浪费掉了，这里改变一下思路，不再使用大顶堆，而是使用小顶堆，这样能够保证每一次弹出的都是出现次数最小的，那么最后保留在堆中的元素就是出现出现次数最大的 k  个 <font color="red"> 还有Bug </font>

***这里对上面的大顶堆实现进行一下更改，使其在堆满的时候先进行弹出操作，让出一个空位，然后进行入堆操作，这样可以减少空间的占用***

***小顶堆的实现***
```java
class minHeap{
    private int size;
    private int index;
    private Pair[] container;

    public minHeap(int size){
        this.size = size + 1;
        this.index = 0;
        this.container = new Pair[this.size];
    }

    // 添加操作
    // 如果 container 的 index < size，说明队列还没有满
    //  > 正常进行添加操作，将元素添加到 ++ index 的位置，对该元素进行 swim 操作，上浮到合适的位置
    // 如果 container 的 index >= size，说明队列已经满了
    //  > 将该元素覆盖到堆的顶部，并对该元素进行 sink 操作，下沉到合适的位置
    public void add(Pair p){
        if(index + 1 < size){
            container[++ index] = p;
            swim(index);
        }else{
            container[1] = p;
            sink(1);
        }
    }

    // 删除操作，从堆顶部删除一个元素
    // 将 container 尾部的元素放到顶部
    // 将队列尾部的元素置空，更新 index
    // 对堆顶部的元素进行 sink 操作
    public Pair del(){
        Pair res = container[1];
        container[1] = container[index --];
        container[index + 1] = null;
        sink(1);
        return res;
    }



    /************************* 辅助函数 ***************************/

    // 上浮 -> 当前元素比其父节点元素小 
    private void swim(int k){
        while(k > 1 && less(k, k / 2)){
            swap(k, k / 2);
            k /= 2;
        }
    }

    // 下沉 -> 当前元素比其父节点元素大
    private void sink(int k){
        while(k * 2 <= index){
            int j = k * 2;
            if(j + 1 <= index && less(j + 1, j)) j += 1;
            swap(k, j);
            k = j;
        }
    }

    private void swap(int i, int j){
        Pair temp = container[i];
        container[i] = container[j];
        container[j] = temp;
    }

    private boolean less(int i, int j){
        return container[i].count < container[j].count;
    }
}

class Pair{
    public int count;
    public int val;
    public Pair(int val, int count){
        this.count = count;
        this.val = val;
    }
}
```