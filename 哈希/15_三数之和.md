# LeetCode15:三数之和

TODO
## 题意理解: 给定一个数组 nums，让你求出三个索引(i, j, k) 对应的元素，要满足 nums[i] + nums[j] + nums[k] = 0，三个索引没有大小区分，只需要满足互不相同即可，最终的结果不能包含重复的数据值的项(重复的项指的是三个数字相同，不考虑在结果数组中的位置)，最后一个条件是最难满足的，因为对于在遍历过程中出现的所有数字组合，需要对其进行去重处理，这里面的逻辑是比较复杂的

**思路一**: 由四数之和可以知道，一般可以用 HashMap 或者 HashSet 来降低循环的嵌套层数，同时因为题目要求对索引进行判断的，所以我们在存放数组中元素的同时得记录下数组中该元素出现的索引的所有的索引的位置，那么此时 HashMap 的结构基本上就确定了，以数组元素为键，数组元素在数组中出现的索引位置的 List 的为值，每次遇到符合条件的情况，只需要判断一下对应元素在索引 List 中所有的记录是否满足题目对索引的要求即可，如果满足条件则进入到下一个判断，即重复元素的判断，这里的逻辑是借助 HashSet 的来帮助我们去重，这里需要构造一个类 ***Pair*** 来帮助题目解决去重的问题，该类必须要重写 ***hashCode***、***equals*** 方法，这里提供的 sort 方法是为了满足题目中要求的不允许存在重复的数据项，所以将三个数按照从大到小进行了排序，这样就能够保证 equals 方法的正确性 <font color="red">TLE，三个样例超时</font>

***Pair***
```java
class Pair{
    int num1;
    int num2;
    int num3;

    public Pair(int num1, int num2, int num3) {
        this.num1 = num1;
        this.num2 = num2;
        this.num3 = num3;
        sort();
    }

    private void sort(){
        int max = 0;
        int mid = 0;
        int min = 0;
        if(num1 >= num2){
            if(num1 >= num3){
                max = num1;

                if(num2 >= num3){
                    mid = num2;
                    min = num3;
                }else{
                    mid = num3;
                    min = num2;
                }
            }else{
                max = num3;
                mid = num1;
                min = num2;
            }
        }else{
            if(num2 >= num3){
                max = num2;
                if(num1 >= num3){
                    mid = num1;
                    min = num3;
                }else{
                    mid = num3;
                    min = num1;
                }
            }else{
                max = num3;
                mid = num2;
                min = num1;
            }
        }

        num1 = max;
        num2 = mid;
        num3 = min;
    }

    @Override
    public int hashCode() {
        return this.num1 + this.num2 + this.num3;
    }

    @Override
    public boolean equals(Object other) {
        if(other instanceof Pair){
            Pair otherP = (Pair) other;
            return this.num1 == otherP.num1 &&
                   this.num2 == otherP.num2 &&
                   this.num3 == otherP.num3;
        }else return false;
    }
}
```

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new LinkedList<List<Integer>>();   
        HashMap<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();
        HashSet<Pair> set = new HashSet<>();
        
        for(int i = 0; i < nums.length; ++ i)
            for(int j = 0; j < nums.length; ++ j){
                if(i != j){
                    if(map.containsKey(-(nums[i] + nums[j])))
                        for(int k : map.get(-(nums[i] + nums[j])))
                            if(j != k && i != k)
                                if(set.add(new Pair(nums[i], nums[j], nums[k]))) 
                                    res.add(new ArrayList<Integer>(Arrays.asList(nums[i], nums[j], nums[k])));
                }else{
                    map.put(nums[i], new LinkedList<Integer>());
                    map.get(nums[i]).add(i);
                }
            }
        
        return res;
    }
}

class Pair{
    int num1;
    int num2;
    int num3;

    public Pair(int num1, int num2, int num3) {
        this.num1 = num1;
        this.num2 = num2;
        this.num3 = num3;
        sort();
    }

    private void sort(){
        int max = 0;
        int mid = 0;
        int min = 0;
        if(num1 >= num2){
            if(num1 >= num3){
                max = num1;

                if(num2 >= num3){
                    mid = num2;
                    min = num3;
                }else{
                    mid = num3;
                    min = num2;
                }
            }else{
                max = num3;
                mid = num1;
                min = num2;
            }
        }else{
            if(num2 >= num3){
                max = num2;
                if(num1 >= num3){
                    mid = num1;
                    min = num3;
                }else{
                    mid = num3;
                    min = num1;
                }
            }else{
                max = num3;
                mid = num2;
                min = num1;
            }
        }

        num1 = max;
        num2 = mid;
        num3 = min;
    }

    @Override
    public int hashCode() {
        return this.num1 + this.num2 + this.num3;
    }

    @Override
    public boolean equals(Object other) {
        if(other instanceof Pair){
            Pair otherP = (Pair) other;
            return this.num1 == otherP.num1 &&
                   this.num2 == otherP.num2 &&
                   this.num3 == otherP.num3;
        }else return false;
    }
}
```

